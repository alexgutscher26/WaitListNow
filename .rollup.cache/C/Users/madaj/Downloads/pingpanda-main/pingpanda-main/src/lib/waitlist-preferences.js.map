{"version":3,"file":"waitlist-preferences.js","sourceRoot":"","sources":["waitlist-preferences.ts"],"names":[],"mappings":"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","sourcesContent":["import { db } from '@/lib/db';\r\n\r\n\r\n// Custom error class for waitlist preferences errors\r\nexport class WaitlistPreferencesError extends Error {\r\n  constructor(\r\n    message: string,\r\n    public code: string = 'WAITLIST_PREFERENCES_ERROR',\r\n  ) {\r\n    super(message);\r\n    this.name = 'WaitlistPreferencesError';\r\n  }\r\n}\r\n\r\nexport interface WaitlistPreferences {\r\n  defaultWaitlistLimit: number;\r\n  autoApproveSubscribers: boolean;\r\n  emailNotifications: boolean;\r\n  maxSubscribers: number;\r\n  requireEmailVerification: boolean;\r\n}\r\n\r\nexport const defaultWaitlistPreferences: WaitlistPreferences = {\r\n  defaultWaitlistLimit: 1,\r\n  autoApproveSubscribers: true,\r\n  emailNotifications: true,\r\n  maxSubscribers: 1000,\r\n  requireEmailVerification: false,\r\n};\r\n\r\nexport async function getUserWaitlistPreferences(userId: string): Promise<WaitlistPreferences> {\r\n  if (!userId) {\r\n    throw new WaitlistPreferencesError('User ID is required', 'USER_ID_REQUIRED');\r\n  }\r\n\r\n  try {\r\n    console.log(`[getUserWaitlistPreferences] Fetching preferences for user: ${userId}`);\r\n\r\n    // First try to get the user with raw SQL\r\n    const result = await db.$queryRaw<Array<{ waitlist_preferences: string | null }>>`\r\n      SELECT \"waitlist_preferences\" as waitlist_preferences\r\n      FROM \"User\" \r\n      WHERE \"externalId\" = ${userId}\r\n      LIMIT 1\r\n    `;\r\n\r\n    if (!result || result.length === 0) {\r\n      console.warn(`[getUserWaitlistPreferences] User not found: ${userId}`);\r\n      throw new WaitlistPreferencesError('User not found', 'USER_NOT_FOUND');\r\n    }\r\n\r\n    const prefsJson = result[0]?.waitlist_preferences;\r\n\r\n    // If no preferences exist yet, return defaults\r\n    if (!prefsJson) {\r\n      console.log(\r\n        `[getUserWaitlistPreferences] No preferences found for user ${userId}, returning defaults`,\r\n      );\r\n      return { ...defaultWaitlistPreferences };\r\n    }\r\n\r\n    // Parse the preferences\r\n    let prefs: Partial<WaitlistPreferences>;\r\n    try {\r\n      prefs = typeof prefsJson === 'string' ? JSON.parse(prefsJson) : prefsJson;\r\n    } catch (parseError) {\r\n      console.error(\r\n        `[getUserWaitlistPreferences] Error parsing preferences for user ${userId}:`,\r\n        parseError,\r\n      );\r\n      // If parsing fails, return defaults\r\n      return { ...defaultWaitlistPreferences };\r\n    }\r\n\r\n    // Merge with defaults to ensure all fields are present\r\n    const mergedPrefs = {\r\n      ...defaultWaitlistPreferences,\r\n      ...prefs,\r\n    };\r\n\r\n    console.log(\r\n      `[getUserWaitlistPreferences] Successfully retrieved preferences for user ${userId}`,\r\n    );\r\n    return mergedPrefs;\r\n  } catch (error) {\r\n    console.error(`[getUserWaitlistPreferences] Error for user ${userId}:`, error);\r\n\r\n    // If it's our custom error, rethrow it\r\n    if (error instanceof WaitlistPreferencesError) {\r\n      throw error;\r\n    }\r\n\r\n    // For other errors, wrap in our custom error\r\n    throw new WaitlistPreferencesError(\r\n      error instanceof Error ? error.message : 'Failed to get waitlist preferences',\r\n      'FETCH_PREFERENCES_FAILED',\r\n    );\r\n  }\r\n}\r\n\r\nexport async function updateUserWaitlistPreferences(\r\n  userId: string,\r\n  updates: Partial<WaitlistPreferences>,\r\n): Promise<WaitlistPreferences> {\r\n  if (!userId) {\r\n    throw new WaitlistPreferencesError('User ID is required', 'USER_ID_REQUIRED');\r\n  }\r\n\r\n  try {\r\n    console.log(`[updateUserWaitlistPreferences] Updating preferences for user: ${userId}`, {\r\n      updates,\r\n    });\r\n\r\n    // Get current preferences\r\n    const currentPrefs = await getUserWaitlistPreferences(userId);\r\n\r\n    // Merge with updates\r\n    const newPrefs = {\r\n      ...currentPrefs,\r\n      ...updates,\r\n      // Ensure maxSubscribers is within bounds\r\n      maxSubscribers: Math.min(\r\n        10000,\r\n        Math.max(100, updates.maxSubscribers ?? currentPrefs.maxSubscribers),\r\n      ),\r\n    };\r\n\r\n    console.log(`[updateUserWaitlistPreferences] New preferences for user ${userId}:`, newPrefs);\r\n\r\n    // Update in database using raw SQL to bypass TypeScript type checking\r\n    const result = await db.$executeRaw`\r\n      UPDATE \"User\"\r\n      SET \r\n        \"waitlist_preferences\" = ${JSON.stringify(newPrefs)}::jsonb,\r\n        \"updatedAt\" = NOW()\r\n      WHERE \"externalId\" = ${userId}\r\n      RETURNING id, \"waitlist_preferences\" as waitlist_preferences\r\n    `;\r\n\r\n    if (result === 0) {\r\n      throw new WaitlistPreferencesError('User not found', 'USER_NOT_FOUND');\r\n    }\r\n\r\n    console.log(\r\n      `[updateUserWaitlistPreferences] Successfully updated preferences for user ${userId}`,\r\n    );\r\n    return newPrefs;\r\n  } catch (error) {\r\n    console.error(`[updateUserWaitlistPreferences] Error for user ${userId}:`, error);\r\n\r\n    // If it's our custom error, rethrow it\r\n    if (error instanceof WaitlistPreferencesError) {\r\n      throw error;\r\n    }\r\n\r\n    // For other errors, wrap in our custom error\r\n    throw new WaitlistPreferencesError(\r\n      error instanceof Error ? error.message : 'Failed to update waitlist preferences',\r\n      'UPDATE_PREFERENCES_FAILED',\r\n    );\r\n  }\r\n}\r\n"]}